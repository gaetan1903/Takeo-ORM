/*
cgo stubs for package core.
File is generated by gopy. Do not edit.
gopy build -output=takeo/core -vm=python3 ./core
*/

package main

/*

#cgo CFLAGS: "-I/usr/include/python3.8" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/usr/lib" "-lpython3.8" -lcrypt -lpthread -ldl  -lutil -lm -lm

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"fmt"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"reflect"

	"github.com/gaetan1903/Takeo-ORM/core"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: core below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: reflect.Type
func ptrFromHandle_reflect_Type(h CGoHandle) reflect.Type {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "reflect.Type")
	if p == nil {
		return nil
	}
	return p.(reflect.Type)
}
func handleFromPtr_reflect_Type(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("reflect.Type", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: core ---

// ---- Types ---

// Converters for pointer handles for type: *core.ColumnMetadata
func ptrFromHandle_Ptr_core_ColumnMetadata(h CGoHandle) *core.ColumnMetadata {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*core.ColumnMetadata")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.ColumnMetadata{})).(*core.ColumnMetadata)
}
func handleFromPtr_Ptr_core_ColumnMetadata(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*core.ColumnMetadata", p))
}

// Converters for pointer handles for type: *core.DB
func ptrFromHandle_Ptr_core_DB(h CGoHandle) *core.DB {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*core.DB")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.DB{})).(*core.DB)
}
func handleFromPtr_Ptr_core_DB(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*core.DB", p))
}

// Converters for pointer handles for type: *core.DatabaseConfig
func ptrFromHandle_Ptr_core_DatabaseConfig(h CGoHandle) *core.DatabaseConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*core.DatabaseConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.DatabaseConfig{})).(*core.DatabaseConfig)
}
func handleFromPtr_Ptr_core_DatabaseConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*core.DatabaseConfig", p))
}

// Converters for pointer handles for type: *core.EntityMetadata
func ptrFromHandle_Ptr_core_EntityMetadata(h CGoHandle) *core.EntityMetadata {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*core.EntityMetadata")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.EntityMetadata{})).(*core.EntityMetadata)
}
func handleFromPtr_Ptr_core_EntityMetadata(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*core.EntityMetadata", p))
}

// Converters for pointer handles for type: *core.EntityRegistry
func ptrFromHandle_Ptr_core_EntityRegistry(h CGoHandle) *core.EntityRegistry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*core.EntityRegistry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.EntityRegistry{})).(*core.EntityRegistry)
}
func handleFromPtr_Ptr_core_EntityRegistry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*core.EntityRegistry", p))
}

// Converters for pointer handles for type: *core.Repository
func ptrFromHandle_Ptr_core_Repository(h CGoHandle) *core.Repository {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*core.Repository")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.Repository{})).(*core.Repository)
}
func handleFromPtr_Ptr_core_Repository(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*core.Repository", p))
}

// Converters for pointer handles for type: *core.TakeoAPI
func ptrFromHandle_Ptr_core_TakeoAPI(h CGoHandle) *core.TakeoAPI {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*core.TakeoAPI")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.TakeoAPI{})).(*core.TakeoAPI)
}
func handleFromPtr_Ptr_core_TakeoAPI(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*core.TakeoAPI", p))
}

// Converters for pointer handles for type: *core.TakeoManager
func ptrFromHandle_Ptr_core_TakeoManager(h CGoHandle) *core.TakeoManager {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*core.TakeoManager")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager)
}
func handleFromPtr_Ptr_core_TakeoManager(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*core.TakeoManager", p))
}

// Converters for pointer handles for type: *core.TakeoORM
func ptrFromHandle_Ptr_core_TakeoORM(h CGoHandle) *core.TakeoORM {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*core.TakeoORM")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.TakeoORM{})).(*core.TakeoORM)
}
func handleFromPtr_Ptr_core_TakeoORM(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*core.TakeoORM", p))
}

// Converters for pointer handles for type: *core.TakeoTransaction
func ptrFromHandle_Ptr_core_TakeoTransaction(h CGoHandle) *core.TakeoTransaction {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*core.TakeoTransaction")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.TakeoTransaction{})).(*core.TakeoTransaction)
}
func handleFromPtr_Ptr_core_TakeoTransaction(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*core.TakeoTransaction", p))
}

// Converters for pointer handles for type: *core.UpdateData
func ptrFromHandle_Ptr_core_UpdateData(h CGoHandle) *core.UpdateData {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*core.UpdateData")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.UpdateData{})).(*core.UpdateData)
}
func handleFromPtr_Ptr_core_UpdateData(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*core.UpdateData", p))
}

// Converters for implicit pointer handles for type: []core.UpdateData
func ptrFromHandle_Slice_core_UpdateData(h CGoHandle) *[]core.UpdateData {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]core.UpdateData")
	if p == nil {
		return nil
	}
	return p.(*[]core.UpdateData)
}
func deptrFromHandle_Slice_core_UpdateData(h CGoHandle) []core.UpdateData {
	p := ptrFromHandle_Slice_core_UpdateData(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_core_UpdateData(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]core.UpdateData", p))
}

// --- wrapping slice: []core.UpdateData ---
//
//export Slice_core_UpdateData_CTor
func Slice_core_UpdateData_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_core_UpdateData(&[]core.UpdateData{}))
}

//export Slice_core_UpdateData_len
func Slice_core_UpdateData_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_core_UpdateData(handle))
}

//export Slice_core_UpdateData_elem
func Slice_core_UpdateData_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_core_UpdateData(handle)
	return handleFromPtr_core_UpdateData(&(s[_idx]))
}

//export Slice_core_UpdateData_subslice
func Slice_core_UpdateData_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_core_UpdateData(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_core_UpdateData(&ss))
}

//export Slice_core_UpdateData_set
func Slice_core_UpdateData_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_core_UpdateData(handle)
	s[_idx] = *ptrFromHandle_core_UpdateData(_vl)
}

//export Slice_core_UpdateData_append
func Slice_core_UpdateData_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_core_UpdateData(handle)
	*s = append(*s, *ptrFromHandle_core_UpdateData(_vl))
}

// Converters for implicit pointer handles for type: []interface{}
func ptrFromHandle_Slice_interface_(h CGoHandle) *[]interface{} {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]interface{}")
	if p == nil {
		return nil
	}
	return p.(*[]interface{})
}
func deptrFromHandle_Slice_interface_(h CGoHandle) []interface{} {
	p := ptrFromHandle_Slice_interface_(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_interface_(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]interface{}", p))
}

// --- wrapping slice: []interface{} ---
//
//export Slice_interface__CTor
func Slice_interface__CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_interface_(&[]interface{}{}))
}

//export Slice_interface__len
func Slice_interface__len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_interface_(handle))
}

//export Slice_interface__elem
func Slice_interface__elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_interface_(handle)
	return C.CString(fmt.Sprintf("%s", (s[_idx])))
}

//export Slice_interface__subslice
func Slice_interface__subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_interface_(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_interface_(&ss))
}

//export Slice_interface__set
func Slice_interface__set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_interface_(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_interface__append
func Slice_interface__append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_interface_(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []map[string]interface{}
func ptrFromHandle_Slice_Map_string_interface_(h CGoHandle) *[]map[string]interface{} {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]map[string]interface{}")
	if p == nil {
		return nil
	}
	return p.(*[]map[string]interface{})
}
func deptrFromHandle_Slice_Map_string_interface_(h CGoHandle) []map[string]interface{} {
	p := ptrFromHandle_Slice_Map_string_interface_(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Map_string_interface_(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]map[string]interface{}", p))
}

// --- wrapping slice: []map[string]interface{} ---
//
//export Slice_Map_string_interface__CTor
func Slice_Map_string_interface__CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Map_string_interface_(&[]map[string]interface{}{}))
}

//export Slice_Map_string_interface__len
func Slice_Map_string_interface__len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Map_string_interface_(handle))
}

//export Slice_Map_string_interface__elem
func Slice_Map_string_interface__elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Map_string_interface_(handle)
	return handleFromPtr_Map_string_interface_(&(s[_idx]))
}

//export Slice_Map_string_interface__subslice
func Slice_Map_string_interface__subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Map_string_interface_(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Map_string_interface_(&ss))
}

//export Slice_Map_string_interface__set
func Slice_Map_string_interface__set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Map_string_interface_(handle)
	s[_idx] = deptrFromHandle_Map_string_interface_(_vl)
}

//export Slice_Map_string_interface__append
func Slice_Map_string_interface__append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Map_string_interface_(handle)
	*s = append(*s, deptrFromHandle_Map_string_interface_(_vl))
}

// Converters for non-pointer handles for type: core.ColumnMetadata
func ptrFromHandle_core_ColumnMetadata(h CGoHandle) *core.ColumnMetadata {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "core.ColumnMetadata")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.ColumnMetadata{})).(*core.ColumnMetadata)
}
func handleFromPtr_core_ColumnMetadata(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("core.ColumnMetadata", p))
}

// Converters for non-pointer handles for type: core.DB
func ptrFromHandle_core_DB(h CGoHandle) *core.DB {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "core.DB")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.DB{})).(*core.DB)
}
func handleFromPtr_core_DB(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("core.DB", p))
}

// Converters for non-pointer handles for type: core.DatabaseConfig
func ptrFromHandle_core_DatabaseConfig(h CGoHandle) *core.DatabaseConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "core.DatabaseConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.DatabaseConfig{})).(*core.DatabaseConfig)
}
func handleFromPtr_core_DatabaseConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("core.DatabaseConfig", p))
}

// Converters for non-pointer handles for type: core.EntityMetadata
func ptrFromHandle_core_EntityMetadata(h CGoHandle) *core.EntityMetadata {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "core.EntityMetadata")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.EntityMetadata{})).(*core.EntityMetadata)
}
func handleFromPtr_core_EntityMetadata(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("core.EntityMetadata", p))
}

// Converters for non-pointer handles for type: core.EntityRegistry
func ptrFromHandle_core_EntityRegistry(h CGoHandle) *core.EntityRegistry {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "core.EntityRegistry")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.EntityRegistry{})).(*core.EntityRegistry)
}
func handleFromPtr_core_EntityRegistry(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("core.EntityRegistry", p))
}

// Converters for non-pointer handles for type: core.Repository
func ptrFromHandle_core_Repository(h CGoHandle) *core.Repository {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "core.Repository")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.Repository{})).(*core.Repository)
}
func handleFromPtr_core_Repository(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("core.Repository", p))
}

// Converters for non-pointer handles for type: core.TakeoAPI
func ptrFromHandle_core_TakeoAPI(h CGoHandle) *core.TakeoAPI {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "core.TakeoAPI")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.TakeoAPI{})).(*core.TakeoAPI)
}
func handleFromPtr_core_TakeoAPI(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("core.TakeoAPI", p))
}

// Converters for non-pointer handles for type: core.TakeoManager
func ptrFromHandle_core_TakeoManager(h CGoHandle) *core.TakeoManager {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "core.TakeoManager")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager)
}
func handleFromPtr_core_TakeoManager(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("core.TakeoManager", p))
}

// Converters for non-pointer handles for type: core.TakeoORM
func ptrFromHandle_core_TakeoORM(h CGoHandle) *core.TakeoORM {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "core.TakeoORM")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.TakeoORM{})).(*core.TakeoORM)
}
func handleFromPtr_core_TakeoORM(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("core.TakeoORM", p))
}

// Converters for non-pointer handles for type: core.TakeoTransaction
func ptrFromHandle_core_TakeoTransaction(h CGoHandle) *core.TakeoTransaction {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "core.TakeoTransaction")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.TakeoTransaction{})).(*core.TakeoTransaction)
}
func handleFromPtr_core_TakeoTransaction(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("core.TakeoTransaction", p))
}

// Converters for non-pointer handles for type: core.UpdateData
func ptrFromHandle_core_UpdateData(h CGoHandle) *core.UpdateData {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "core.UpdateData")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(core.UpdateData{})).(*core.UpdateData)
}
func handleFromPtr_core_UpdateData(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("core.UpdateData", p))
}

// Converters for implicit pointer handles for type: map[string]core.ColumnMetadata
func ptrFromHandle_Map_string_core_ColumnMetadata(h CGoHandle) *map[string]core.ColumnMetadata {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]core.ColumnMetadata")
	if p == nil {
		return nil
	}
	return p.(*map[string]core.ColumnMetadata)
}
func deptrFromHandle_Map_string_core_ColumnMetadata(h CGoHandle) map[string]core.ColumnMetadata {
	p := ptrFromHandle_Map_string_core_ColumnMetadata(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_core_ColumnMetadata(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]core.ColumnMetadata", p))
}

// --- wrapping map: map[string]core.ColumnMetadata ---
//
//export Map_string_core_ColumnMetadata_CTor
func Map_string_core_ColumnMetadata_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_core_ColumnMetadata(&map[string]core.ColumnMetadata{}))
}

//export Map_string_core_ColumnMetadata_len
func Map_string_core_ColumnMetadata_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_core_ColumnMetadata(handle))
}

//export Map_string_core_ColumnMetadata_elem
func Map_string_core_ColumnMetadata_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_core_ColumnMetadata(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_core_ColumnMetadata(&v)
}

//export Map_string_core_ColumnMetadata_contains
func Map_string_core_ColumnMetadata_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_core_ColumnMetadata(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_core_ColumnMetadata_set
func Map_string_core_ColumnMetadata_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_core_ColumnMetadata(handle)
	s[C.GoString(_ky)] = *ptrFromHandle_core_ColumnMetadata(_vl)
}

//export Map_string_core_ColumnMetadata_delete
func Map_string_core_ColumnMetadata_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_core_ColumnMetadata(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_core_ColumnMetadata_keys
func Map_string_core_ColumnMetadata_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_core_ColumnMetadata(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]interface{}
func ptrFromHandle_Map_string_interface_(h CGoHandle) *map[string]interface{} {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]interface{}")
	if p == nil {
		return nil
	}
	return p.(*map[string]interface{})
}
func deptrFromHandle_Map_string_interface_(h CGoHandle) map[string]interface{} {
	p := ptrFromHandle_Map_string_interface_(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_interface_(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]interface{}", p))
}

// --- wrapping map: map[string]interface{} ---
//
//export Map_string_interface__CTor
func Map_string_interface__CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_interface_(&map[string]interface{}{}))
}

//export Map_string_interface__len
func Map_string_interface__len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_interface_(handle))
}

//export Map_string_interface__elem
func Map_string_interface__elem(handle CGoHandle, _ky *C.char) *C.char {
	s := deptrFromHandle_Map_string_interface_(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(fmt.Sprintf("%s", (v)))
}

//export Map_string_interface__contains
func Map_string_interface__contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_interface_(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_interface__set
func Map_string_interface__set(handle CGoHandle, _ky *C.char, _vl *C.char) {
	s := deptrFromHandle_Map_string_interface_(handle)
	s[C.GoString(_ky)] = C.GoString(_vl)
}

//export Map_string_interface__delete
func Map_string_interface__delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_interface_(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_interface__keys
func Map_string_interface__keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_interface_(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]string
func ptrFromHandle_Map_string_string(h CGoHandle) *map[string]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]string")
	if p == nil {
		return nil
	}
	return p.(*map[string]string)
}
func deptrFromHandle_Map_string_string(h CGoHandle) map[string]string {
	p := ptrFromHandle_Map_string_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]string", p))
}

// --- wrapping map: map[string]string ---
//
//export Map_string_string_CTor
func Map_string_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_string(&map[string]string{}))
}

//export Map_string_string_len
func Map_string_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_string(handle))
}

//export Map_string_string_elem
func Map_string_string_elem(handle CGoHandle, _ky *C.char) *C.char {
	s := deptrFromHandle_Map_string_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(v)
}

//export Map_string_string_contains
func Map_string_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_string_set
func Map_string_string_set(handle CGoHandle, _ky *C.char, _vl *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	s[C.GoString(_ky)] = C.GoString(_vl)
}

//export Map_string_string_delete
func Map_string_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_string_keys
func Map_string_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: core.DatabaseConfig ---
//
//export core_DatabaseConfig_CTor
func core_DatabaseConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_core_DatabaseConfig(&core.DatabaseConfig{}))
}

//export core_DatabaseConfig_Host_Get
func core_DatabaseConfig_Host_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_core_DatabaseConfig(handle)
	return C.CString(op.Host)
}

//export core_DatabaseConfig_Host_Set
func core_DatabaseConfig_Host_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_core_DatabaseConfig(handle)
	op.Host = C.GoString(val)
}

//export core_DatabaseConfig_Port_Get
func core_DatabaseConfig_Port_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_core_DatabaseConfig(handle)
	return C.longlong(op.Port)
}

//export core_DatabaseConfig_Port_Set
func core_DatabaseConfig_Port_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_core_DatabaseConfig(handle)
	op.Port = int(val)
}

//export core_DatabaseConfig_User_Get
func core_DatabaseConfig_User_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_core_DatabaseConfig(handle)
	return C.CString(op.User)
}

//export core_DatabaseConfig_User_Set
func core_DatabaseConfig_User_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_core_DatabaseConfig(handle)
	op.User = C.GoString(val)
}

//export core_DatabaseConfig_Password_Get
func core_DatabaseConfig_Password_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_core_DatabaseConfig(handle)
	return C.CString(op.Password)
}

//export core_DatabaseConfig_Password_Set
func core_DatabaseConfig_Password_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_core_DatabaseConfig(handle)
	op.Password = C.GoString(val)
}

//export core_DatabaseConfig_Database_Get
func core_DatabaseConfig_Database_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_core_DatabaseConfig(handle)
	return C.CString(op.Database)
}

//export core_DatabaseConfig_Database_Set
func core_DatabaseConfig_Database_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_core_DatabaseConfig(handle)
	op.Database = C.GoString(val)
}

//export core_DatabaseConfig_SSLMode_Get
func core_DatabaseConfig_SSLMode_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_core_DatabaseConfig(handle)
	return C.CString(op.SSLMode)
}

//export core_DatabaseConfig_SSLMode_Set
func core_DatabaseConfig_SSLMode_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_core_DatabaseConfig(handle)
	op.SSLMode = C.GoString(val)
}

// --- wrapping struct: core.EntityRegistry ---
//
//export core_EntityRegistry_CTor
func core_EntityRegistry_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_core_EntityRegistry(&core.EntityRegistry{}))
}

//export core_EntityRegistry_RegisterEntity
func core_EntityRegistry_RegisterEntity(_handle CGoHandle, entityType CGoHandle, tableName *C.char, metadata CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.EntityRegistry")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(core.EntityRegistry{})).(*core.EntityRegistry).RegisterEntity(ptrFromHandle_reflect_Type(entityType), C.GoString(tableName), ptrFromHandle_Ptr_core_EntityMetadata(metadata))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(core.EntityRegistry{})).(*core.EntityRegistry).RegisterEntity(ptrFromHandle_reflect_Type(entityType), C.GoString(tableName), ptrFromHandle_Ptr_core_EntityMetadata(metadata))
	}
}

//export core_EntityRegistry_RegisterEntityByName
func core_EntityRegistry_RegisterEntityByName(_handle CGoHandle, entityName *C.char, metadata CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.EntityRegistry")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(core.EntityRegistry{})).(*core.EntityRegistry).RegisterEntityByName(C.GoString(entityName), ptrFromHandle_Ptr_core_EntityMetadata(metadata))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(core.EntityRegistry{})).(*core.EntityRegistry).RegisterEntityByName(C.GoString(entityName), ptrFromHandle_Ptr_core_EntityMetadata(metadata))
	}
}

//export core_EntityRegistry_GetEntityGopy
func core_EntityRegistry_GetEntityGopy(_handle CGoHandle, typeName *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.EntityRegistry")
	if __err != nil {
		return handleFromPtr_Ptr_core_EntityMetadata(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.EntityRegistry{})).(*core.EntityRegistry).GetEntityGopy(C.GoString(typeName))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_core_EntityMetadata(nil)
	}
	return handleFromPtr_Ptr_core_EntityMetadata(cret)
}

// --- wrapping struct: core.TakeoAPI ---
//
//export core_TakeoAPI_CTor
func core_TakeoAPI_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_core_TakeoAPI(&core.TakeoAPI{}))
}

//export core_TakeoAPI_RegisterEntity
func core_TakeoAPI_RegisterEntity(_handle CGoHandle, name *C.char, tableName *C.char, columnsJSON *C.char, primaryKey *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoAPI")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoAPI{})).(*core.TakeoAPI).RegisterEntity(C.GoString(name), C.GoString(tableName), C.GoString(columnsJSON), C.GoString(primaryKey))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoAPI_Save
func core_TakeoAPI_Save(_handle CGoHandle, entityType *C.char, dataJSON *C.char) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoAPI")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.TakeoAPI{})).(*core.TakeoAPI).Save(C.GoString(entityType), C.GoString(dataJSON))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

//export core_TakeoAPI_FindByID
func core_TakeoAPI_FindByID(_handle CGoHandle, entityType *C.char, id C.longlong) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoAPI")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.TakeoAPI{})).(*core.TakeoAPI).FindByID(C.GoString(entityType), int64(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export core_TakeoAPI_FindAll
func core_TakeoAPI_FindAll(_handle CGoHandle, entityType *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoAPI")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.TakeoAPI{})).(*core.TakeoAPI).FindAll(C.GoString(entityType))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export core_TakeoAPI_Update
func core_TakeoAPI_Update(_handle CGoHandle, entityType *C.char, id C.longlong, updateJSON *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoAPI")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoAPI{})).(*core.TakeoAPI).Update(C.GoString(entityType), int64(id), C.GoString(updateJSON))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoAPI_Delete
func core_TakeoAPI_Delete(_handle CGoHandle, entityType *C.char, id C.longlong) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoAPI")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoAPI{})).(*core.TakeoAPI).Delete(C.GoString(entityType), int64(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoAPI_CreateTable
func core_TakeoAPI_CreateTable(_handle CGoHandle, entityType *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoAPI")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoAPI{})).(*core.TakeoAPI).CreateTable(C.GoString(entityType))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoAPI_DropTable
func core_TakeoAPI_DropTable(_handle CGoHandle, entityType *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoAPI")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoAPI{})).(*core.TakeoAPI).DropTable(C.GoString(entityType))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoAPI_Close
func core_TakeoAPI_Close(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoAPI")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoAPI{})).(*core.TakeoAPI).Close()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoAPI_Ping
func core_TakeoAPI_Ping(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoAPI")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoAPI{})).(*core.TakeoAPI).Ping()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: core.ColumnMetadata ---
//
//export core_ColumnMetadata_CTor
func core_ColumnMetadata_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_core_ColumnMetadata(&core.ColumnMetadata{}))
}

//export core_ColumnMetadata_Name_Get
func core_ColumnMetadata_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_core_ColumnMetadata(handle)
	return C.CString(op.Name)
}

//export core_ColumnMetadata_Name_Set
func core_ColumnMetadata_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_core_ColumnMetadata(handle)
	op.Name = C.GoString(val)
}

//export core_ColumnMetadata_Type_Get
func core_ColumnMetadata_Type_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_core_ColumnMetadata(handle)
	return C.CString(op.Type)
}

//export core_ColumnMetadata_Type_Set
func core_ColumnMetadata_Type_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_core_ColumnMetadata(handle)
	op.Type = C.GoString(val)
}

//export core_ColumnMetadata_IsPrimaryKey_Get
func core_ColumnMetadata_IsPrimaryKey_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_core_ColumnMetadata(handle)
	return boolGoToPy(op.IsPrimaryKey)
}

//export core_ColumnMetadata_IsPrimaryKey_Set
func core_ColumnMetadata_IsPrimaryKey_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_core_ColumnMetadata(handle)
	op.IsPrimaryKey = boolPyToGo(val)
}

//export core_ColumnMetadata_IsAutoIncrement_Get
func core_ColumnMetadata_IsAutoIncrement_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_core_ColumnMetadata(handle)
	return boolGoToPy(op.IsAutoIncrement)
}

//export core_ColumnMetadata_IsAutoIncrement_Set
func core_ColumnMetadata_IsAutoIncrement_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_core_ColumnMetadata(handle)
	op.IsAutoIncrement = boolPyToGo(val)
}

//export core_ColumnMetadata_IsNullable_Get
func core_ColumnMetadata_IsNullable_Get(handle CGoHandle) C.char {
	op := ptrFromHandle_core_ColumnMetadata(handle)
	return boolGoToPy(op.IsNullable)
}

//export core_ColumnMetadata_IsNullable_Set
func core_ColumnMetadata_IsNullable_Set(handle CGoHandle, val C.char) {
	op := ptrFromHandle_core_ColumnMetadata(handle)
	op.IsNullable = boolPyToGo(val)
}

// --- wrapping struct: core.DB ---
//
//export core_DB_CTor
func core_DB_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_core_DB(&core.DB{}))
}

//export core_DB_Close
func core_DB_Close(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.DB")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.DB{})).(*core.DB).Close()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_DB_Ping
func core_DB_Ping(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.DB")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.DB{})).(*core.DB).Ping()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: core.TakeoManager ---
//
//export core_TakeoManager_CTor
func core_TakeoManager_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_core_TakeoManager(&core.TakeoManager{}))
}

//export core_TakeoManager_RegisterEntity
func core_TakeoManager_RegisterEntity(_handle CGoHandle, name *C.char, tableName *C.char, columns CGoHandle, primaryKey *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).RegisterEntity(C.GoString(name), C.GoString(tableName), deptrFromHandle_Map_string_string(columns), C.GoString(primaryKey))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoManager_Save
func core_TakeoManager_Save(_handle CGoHandle, entityType *C.char, entityData CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).Save(C.GoString(entityType), deptrFromHandle_Map_string_interface_(entityData))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

//export core_TakeoManager_SaveBatch
func core_TakeoManager_SaveBatch(_handle CGoHandle, entityType *C.char, entitiesData CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return handleFromPtr_Slice_int64(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).SaveBatch(C.GoString(entityType), deptrFromHandle_Slice_Map_string_interface_(entitiesData))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_int64(nil)
	}
	return handleFromPtr_Slice_int64(&cret)
}

//export core_TakeoManager_FindByID
func core_TakeoManager_FindByID(_handle CGoHandle, entityType *C.char, id C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return handleFromPtr_Map_string_interface_(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).FindByID(C.GoString(entityType), int64(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Map_string_interface_(nil)
	}
	return handleFromPtr_Map_string_interface_(&cret)
}

//export core_TakeoManager_FindAll
func core_TakeoManager_FindAll(_handle CGoHandle, entityType *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return handleFromPtr_Slice_Map_string_interface_(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).FindAll(C.GoString(entityType))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_Map_string_interface_(nil)
	}
	return handleFromPtr_Slice_Map_string_interface_(&cret)
}

//export core_TakeoManager_FindWhere
func core_TakeoManager_FindWhere(_handle CGoHandle, entityType *C.char, conditions CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return handleFromPtr_Slice_Map_string_interface_(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).FindWhere(C.GoString(entityType), deptrFromHandle_Map_string_interface_(conditions))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_Map_string_interface_(nil)
	}
	return handleFromPtr_Slice_Map_string_interface_(&cret)
}

//export core_TakeoManager_Update
func core_TakeoManager_Update(_handle CGoHandle, entityType *C.char, id C.longlong, updates CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).Update(C.GoString(entityType), int64(id), deptrFromHandle_Map_string_interface_(updates))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoManager_UpdateBatch
func core_TakeoManager_UpdateBatch(_handle CGoHandle, entityType *C.char, updates CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).UpdateBatch(C.GoString(entityType), deptrFromHandle_Slice_core_UpdateData(updates))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoManager_Delete
func core_TakeoManager_Delete(_handle CGoHandle, entityType *C.char, id C.longlong) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).Delete(C.GoString(entityType), int64(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoManager_DeleteBatch
func core_TakeoManager_DeleteBatch(_handle CGoHandle, entityType *C.char, ids CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).DeleteBatch(C.GoString(entityType), deptrFromHandle_Slice_int64(ids))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoManager_DeleteWhere
func core_TakeoManager_DeleteWhere(_handle CGoHandle, entityType *C.char, conditions CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).DeleteWhere(C.GoString(entityType), deptrFromHandle_Map_string_interface_(conditions))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

//export core_TakeoManager_CreateTable
func core_TakeoManager_CreateTable(_handle CGoHandle, entityType *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).CreateTable(C.GoString(entityType))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoManager_DropTable
func core_TakeoManager_DropTable(_handle CGoHandle, entityType *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).DropTable(C.GoString(entityType))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoManager_BeginTransaction
func core_TakeoManager_BeginTransaction(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return handleFromPtr_Ptr_core_TakeoTransaction(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).BeginTransaction()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_core_TakeoTransaction(nil)
	}
	return handleFromPtr_Ptr_core_TakeoTransaction(cret)
}

//export core_TakeoManager_Close
func core_TakeoManager_Close(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).Close()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoManager_Ping
func core_TakeoManager_Ping(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoManager{})).(*core.TakeoManager).Ping()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: core.TakeoORM ---
//
//export core_TakeoORM_CTor
func core_TakeoORM_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_core_TakeoORM(&core.TakeoORM{}))
}

//export core_TakeoORM_Close
func core_TakeoORM_Close(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoORM")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoORM{})).(*core.TakeoORM).Close()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoORM_Ping
func core_TakeoORM_Ping(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoORM")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoORM{})).(*core.TakeoORM).Ping()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoORM_RegisterEntityByName
func core_TakeoORM_RegisterEntityByName(_handle CGoHandle, typeName *C.char, tableName *C.char, columns CGoHandle, primaryKey *C.char, autoIncrementColumns CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoORM")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(core.TakeoORM{})).(*core.TakeoORM).RegisterEntityByName(C.GoString(typeName), C.GoString(tableName), deptrFromHandle_Map_string_string(columns), C.GoString(primaryKey), deptrFromHandle_Slice_string(autoIncrementColumns))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(core.TakeoORM{})).(*core.TakeoORM).RegisterEntityByName(C.GoString(typeName), C.GoString(tableName), deptrFromHandle_Map_string_string(columns), C.GoString(primaryKey), deptrFromHandle_Slice_string(autoIncrementColumns))
	}
}

//export core_TakeoORM_CreateEntity
func core_TakeoORM_CreateEntity(_handle CGoHandle, typeName *C.char, values CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoORM")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoORM{})).(*core.TakeoORM).CreateEntity(C.GoString(typeName), deptrFromHandle_Map_string_interface_(values))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoORM_CreateEntitiesBatch
func core_TakeoORM_CreateEntitiesBatch(_handle CGoHandle, typeName *C.char, entitiesData CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoORM")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoORM{})).(*core.TakeoORM).CreateEntitiesBatch(C.GoString(typeName), deptrFromHandle_Slice_Map_string_interface_(entitiesData))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoORM_FindEntityByID
func core_TakeoORM_FindEntityByID(_handle CGoHandle, typeName *C.char, id *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoORM")
	if __err != nil {
		return handleFromPtr_Map_string_interface_(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.TakeoORM{})).(*core.TakeoORM).FindEntityByID(C.GoString(typeName), C.GoString(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Map_string_interface_(nil)
	}
	return handleFromPtr_Map_string_interface_(&cret)
}

//export core_TakeoORM_FindAllEntities
func core_TakeoORM_FindAllEntities(_handle CGoHandle, typeName *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoORM")
	if __err != nil {
		return handleFromPtr_Slice_Map_string_interface_(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.TakeoORM{})).(*core.TakeoORM).FindAllEntities(C.GoString(typeName))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_Map_string_interface_(nil)
	}
	return handleFromPtr_Slice_Map_string_interface_(&cret)
}

//export core_TakeoORM_UpdateEntity
func core_TakeoORM_UpdateEntity(_handle CGoHandle, typeName *C.char, id *C.char, values CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoORM")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoORM{})).(*core.TakeoORM).UpdateEntity(C.GoString(typeName), C.GoString(id), deptrFromHandle_Map_string_interface_(values))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoORM_DeleteEntity
func core_TakeoORM_DeleteEntity(_handle CGoHandle, typeName *C.char, id *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoORM")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoORM{})).(*core.TakeoORM).DeleteEntity(C.GoString(typeName), C.GoString(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoORM_DeleteEntitiesBatch
func core_TakeoORM_DeleteEntitiesBatch(_handle CGoHandle, typeName *C.char, ids CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoORM")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoORM{})).(*core.TakeoORM).DeleteEntitiesBatch(C.GoString(typeName), deptrFromHandle_Slice_interface_(ids))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: core.TakeoTransaction ---
//
//export core_TakeoTransaction_CTor
func core_TakeoTransaction_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_core_TakeoTransaction(&core.TakeoTransaction{}))
}

//export core_TakeoTransaction_Save
func core_TakeoTransaction_Save(_handle CGoHandle, entityType *C.char, entityData CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoTransaction")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(core.TakeoTransaction{})).(*core.TakeoTransaction).Save(C.GoString(entityType), deptrFromHandle_Map_string_interface_(entityData))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

//export core_TakeoTransaction_Commit
func core_TakeoTransaction_Commit(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoTransaction")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoTransaction{})).(*core.TakeoTransaction).Commit()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_TakeoTransaction_Rollback
func core_TakeoTransaction_Rollback(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.TakeoTransaction")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.TakeoTransaction{})).(*core.TakeoTransaction).Rollback()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: core.UpdateData ---
//
//export core_UpdateData_CTor
func core_UpdateData_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_core_UpdateData(&core.UpdateData{}))
}

//export core_UpdateData_ID_Get
func core_UpdateData_ID_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_core_UpdateData(handle)
	return C.longlong(op.ID)
}

//export core_UpdateData_ID_Set
func core_UpdateData_ID_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_core_UpdateData(handle)
	op.ID = int64(val)
}

//export core_UpdateData_Updates_Get
func core_UpdateData_Updates_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_core_UpdateData(handle)
	return handleFromPtr_Map_string_interface_(&op.Updates)
}

//export core_UpdateData_Updates_Set
func core_UpdateData_Updates_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_core_UpdateData(handle)
	op.Updates = deptrFromHandle_Map_string_interface_(val)
}

// --- wrapping struct: core.EntityMetadata ---
//
//export core_EntityMetadata_CTor
func core_EntityMetadata_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_core_EntityMetadata(&core.EntityMetadata{}))
}

//export core_EntityMetadata_TableName_Get
func core_EntityMetadata_TableName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_core_EntityMetadata(handle)
	return C.CString(op.TableName)
}

//export core_EntityMetadata_TableName_Set
func core_EntityMetadata_TableName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_core_EntityMetadata(handle)
	op.TableName = C.GoString(val)
}

//export core_EntityMetadata_PrimaryKey_Get
func core_EntityMetadata_PrimaryKey_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_core_EntityMetadata(handle)
	return C.CString(op.PrimaryKey)
}

//export core_EntityMetadata_PrimaryKey_Set
func core_EntityMetadata_PrimaryKey_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_core_EntityMetadata(handle)
	op.PrimaryKey = C.GoString(val)
}

//export core_EntityMetadata_Columns_Get
func core_EntityMetadata_Columns_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_core_EntityMetadata(handle)
	return handleFromPtr_Map_string_core_ColumnMetadata(&op.Columns)
}

//export core_EntityMetadata_Columns_Set
func core_EntityMetadata_Columns_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_core_EntityMetadata(handle)
	op.Columns = deptrFromHandle_Map_string_core_ColumnMetadata(val)
}

//export core_EntityMetadata_ColumnOrder_Get
func core_EntityMetadata_ColumnOrder_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_core_EntityMetadata(handle)
	return handleFromPtr_Slice_string(&op.ColumnOrder)
}

//export core_EntityMetadata_ColumnOrder_Set
func core_EntityMetadata_ColumnOrder_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_core_EntityMetadata(handle)
	op.ColumnOrder = deptrFromHandle_Slice_string(val)
}

//export core_EntityMetadata_BuildSelectQuery
func core_EntityMetadata_BuildSelectQuery(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.EntityMetadata")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(core.EntityMetadata{})).(*core.EntityMetadata).BuildSelectQuery())

}

//export core_EntityMetadata_BuildInsertQuery
func core_EntityMetadata_BuildInsertQuery(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.EntityMetadata")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(core.EntityMetadata{})).(*core.EntityMetadata).BuildInsertQuery())

}

//export core_EntityMetadata_BuildUpdateQuery
func core_EntityMetadata_BuildUpdateQuery(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.EntityMetadata")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(core.EntityMetadata{})).(*core.EntityMetadata).BuildUpdateQuery())

}

//export core_EntityMetadata_BuildDeleteQuery
func core_EntityMetadata_BuildDeleteQuery(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.EntityMetadata")
	if __err != nil {
		return C.CString("")
	}
	return C.CString(gopyh.Embed(vifc, reflect.TypeOf(core.EntityMetadata{})).(*core.EntityMetadata).BuildDeleteQuery())

}

// --- wrapping struct: core.Repository ---
//
//export core_Repository_CTor
func core_Repository_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_core_Repository(&core.Repository{}))
}

//export core_Repository_Create
func core_Repository_Create(_handle CGoHandle, entity *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.Repository")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.Repository{})).(*core.Repository).Create(C.GoString(entity))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_Repository_FindByID
func core_Repository_FindByID(_handle CGoHandle, entityType CGoHandle, id *C.char, result *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.Repository")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.Repository{})).(*core.Repository).FindByID(ptrFromHandle_reflect_Type(entityType), C.GoString(id), C.GoString(result))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_Repository_FindAll
func core_Repository_FindAll(_handle CGoHandle, entityType CGoHandle, results *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.Repository")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.Repository{})).(*core.Repository).FindAll(ptrFromHandle_reflect_Type(entityType), C.GoString(results))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_Repository_Update
func core_Repository_Update(_handle CGoHandle, entity *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.Repository")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.Repository{})).(*core.Repository).Update(C.GoString(entity))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export core_Repository_Delete
func core_Repository_Delete(_handle CGoHandle, entityType CGoHandle, id *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*core.Repository")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(core.Repository{})).(*core.Repository).Delete(ptrFromHandle_reflect_Type(entityType), C.GoString(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export core_NewEntityRegistry
func core_NewEntityRegistry() CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_core_EntityRegistry(core.NewEntityRegistry())

}

//export core_NewTakeoAPI
func core_NewTakeoAPI(host *C.char, port C.longlong, user *C.char, password *C.char, database *C.char, sslmode *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := core.NewTakeoAPI(C.GoString(host), int(port), C.GoString(user), C.GoString(password), C.GoString(database), C.GoString(sslmode))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_core_TakeoAPI(nil)
	}
	return handleFromPtr_Ptr_core_TakeoAPI(cret)
}

//export core_NewDB
func core_NewDB(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := core.NewDB(ptrFromHandle_Ptr_core_DatabaseConfig(config))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_core_DB(nil)
	}
	return handleFromPtr_Ptr_core_DB(cret)
}

//export core_NewTakeoManager
func core_NewTakeoManager(host *C.char, port C.longlong, user *C.char, password *C.char, database *C.char, sslmode *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := core.NewTakeoManager(C.GoString(host), int(port), C.GoString(user), C.GoString(password), C.GoString(database), C.GoString(sslmode))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_core_TakeoManager(nil)
	}
	return handleFromPtr_Ptr_core_TakeoManager(cret)
}

//export core_NewTakeoORM
func core_NewTakeoORM(host *C.char, port C.longlong, user *C.char, password *C.char, database *C.char, sslmode *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := core.NewTakeoORM(C.GoString(host), int(port), C.GoString(user), C.GoString(password), C.GoString(database), C.GoString(sslmode))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_core_TakeoORM(nil)
	}
	return handleFromPtr_Ptr_core_TakeoORM(cret)
}

//export core_ExtractEntityMetadata
func core_ExtractEntityMetadata(entityType CGoHandle, tableName *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_core_EntityMetadata(core.ExtractEntityMetadata(ptrFromHandle_reflect_Type(entityType), C.GoString(tableName)))

}

//export core_NewRepository
func core_NewRepository(db CGoHandle, registry CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_core_Repository(core.NewRepository(ptrFromHandle_Ptr_core_DB(db), ptrFromHandle_Ptr_core_EntityRegistry(registry)))

}

// ---- Functions ---
