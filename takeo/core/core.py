
# python wrapper for package github.com/gaetan1903/Takeo-ORM/core within overall package core
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -output=takeo/core -vm=python3 ./core

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _core
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from core import core
# and then refer to everything using core. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice []core.UpdateData
class Slice_core_UpdateData(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.Slice_core_UpdateData_CTor()
			_core.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_core_UpdateData.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		s = 'core.Slice_core_UpdateData len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'core.Slice_core_UpdateData([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _core.Slice_core_UpdateData_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _core.Slice_core_UpdateData_len(self.handle)
				return Slice_core_UpdateData(handle=_core.Slice_core_UpdateData_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return UpdateData(handle=_core.Slice_core_UpdateData_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_core.Slice_core_UpdateData_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_core_UpdateData.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = UpdateData(handle=_core.Slice_core_UpdateData_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_core.Slice_core_UpdateData_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []interface{}
class Slice_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.Slice_interface__CTor()
			_core.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_interface_.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		s = 'core.Slice_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'core.Slice_interface_([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _core.Slice_interface__len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _core.Slice_interface__len(self.handle)
				return Slice_interface_(handle=_core.Slice_interface__subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _core.Slice_interface__elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_core.Slice_interface__set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_interface_.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _core.Slice_interface__elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_core.Slice_interface__append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []map[string]interface{}
class Slice_Map_string_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.Slice_Map_string_interface__CTor()
			_core.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Map_string_interface_.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		s = 'core.Slice_Map_string_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'core.Slice_Map_string_interface_([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _core.Slice_Map_string_interface__len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _core.Slice_Map_string_interface__len(self.handle)
				return Slice_Map_string_interface_(handle=_core.Slice_Map_string_interface__subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Map_string_interface_(handle=_core.Slice_Map_string_interface__elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_core.Slice_Map_string_interface__set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Map_string_interface_.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Map_string_interface_(handle=_core.Slice_Map_string_interface__elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_core.Slice_Map_string_interface__append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[string]core.ColumnMetadata
class Map_string_core_ColumnMetadata(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.Map_string_core_ColumnMetadata_CTor()
			_core.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_core_ColumnMetadata.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_core.Map_string_core_ColumnMetadata_set(self.handle, k, v)
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		s = 'core.Map_string_core_ColumnMetadata len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'core.Map_string_core_ColumnMetadata({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _core.Map_string_core_ColumnMetadata_len(self.handle)
	def __getitem__(self, key):
		return ColumnMetadata(handle=_core.Map_string_core_ColumnMetadata_elem(self.handle, key))
	def __setitem__(self, key, value):
		_core.Map_string_core_ColumnMetadata_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _core.Map_string_core_ColumnMetadata_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_core.Map_string_core_ColumnMetadata_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _core.Map_string_core_ColumnMetadata_contains(self.handle, key)

# Python type for map map[string]interface{}
class Map_string_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.Map_string_interface__CTor()
			_core.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_interface_.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_core.Map_string_interface__set(self.handle, k, v)
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		s = 'core.Map_string_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'core.Map_string_interface_({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _core.Map_string_interface__len(self.handle)
	def __getitem__(self, key):
		return _core.Map_string_interface__elem(self.handle, key)
	def __setitem__(self, key, value):
		_core.Map_string_interface__set(self.handle, key, value)
	def __delitem__(self, key):
		return _core.Map_string_interface__delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_core.Map_string_interface__keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _core.Map_string_interface__contains(self.handle, key)

# Python type for map map[string]string
class Map_string_string(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.Map_string_string_CTor()
			_core.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_string.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_core.Map_string_string_set(self.handle, k, v)
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		s = 'core.Map_string_string len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'core.Map_string_string({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _core.Map_string_string_len(self.handle)
	def __getitem__(self, key):
		return _core.Map_string_string_elem(self.handle, key)
	def __setitem__(self, key, value):
		_core.Map_string_string_set(self.handle, key, value)
	def __delitem__(self, key):
		return _core.Map_string_string_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_core.Map_string_string_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _core.Map_string_string_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct core.DatabaseConfig
class DatabaseConfig(go.GoClass):
	"""DatabaseConfig holds database connection configuration\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.core_DatabaseConfig_CTor()
			_core.IncRef(self.handle)
			if  0 < len(args):
				self.Host = args[0]
			if "Host" in kwargs:
				self.Host = kwargs["Host"]
			if  1 < len(args):
				self.Port = args[1]
			if "Port" in kwargs:
				self.Port = kwargs["Port"]
			if  2 < len(args):
				self.User = args[2]
			if "User" in kwargs:
				self.User = kwargs["User"]
			if  3 < len(args):
				self.Password = args[3]
			if "Password" in kwargs:
				self.Password = kwargs["Password"]
			if  4 < len(args):
				self.Database = args[4]
			if "Database" in kwargs:
				self.Database = kwargs["Database"]
			if  5 < len(args):
				self.SSLMode = args[5]
			if "SSLMode" in kwargs:
				self.SSLMode = kwargs["SSLMode"]
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.DatabaseConfig{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.DatabaseConfig ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Host(self):
		return _core.core_DatabaseConfig_Host_Get(self.handle)
	@Host.setter
	def Host(self, value):
		if isinstance(value, go.GoClass):
			_core.core_DatabaseConfig_Host_Set(self.handle, value.handle)
		else:
			_core.core_DatabaseConfig_Host_Set(self.handle, value)
	@property
	def Port(self):
		return _core.core_DatabaseConfig_Port_Get(self.handle)
	@Port.setter
	def Port(self, value):
		if isinstance(value, go.GoClass):
			_core.core_DatabaseConfig_Port_Set(self.handle, value.handle)
		else:
			_core.core_DatabaseConfig_Port_Set(self.handle, value)
	@property
	def User(self):
		return _core.core_DatabaseConfig_User_Get(self.handle)
	@User.setter
	def User(self, value):
		if isinstance(value, go.GoClass):
			_core.core_DatabaseConfig_User_Set(self.handle, value.handle)
		else:
			_core.core_DatabaseConfig_User_Set(self.handle, value)
	@property
	def Password(self):
		return _core.core_DatabaseConfig_Password_Get(self.handle)
	@Password.setter
	def Password(self, value):
		if isinstance(value, go.GoClass):
			_core.core_DatabaseConfig_Password_Set(self.handle, value.handle)
		else:
			_core.core_DatabaseConfig_Password_Set(self.handle, value)
	@property
	def Database(self):
		return _core.core_DatabaseConfig_Database_Get(self.handle)
	@Database.setter
	def Database(self, value):
		if isinstance(value, go.GoClass):
			_core.core_DatabaseConfig_Database_Set(self.handle, value.handle)
		else:
			_core.core_DatabaseConfig_Database_Set(self.handle, value)
	@property
	def SSLMode(self):
		return _core.core_DatabaseConfig_SSLMode_Get(self.handle)
	@SSLMode.setter
	def SSLMode(self, value):
		if isinstance(value, go.GoClass):
			_core.core_DatabaseConfig_SSLMode_Set(self.handle, value.handle)
		else:
			_core.core_DatabaseConfig_SSLMode_Set(self.handle, value)

# Python type for struct core.EntityRegistry
class EntityRegistry(go.GoClass):
	"""EntityRegistry manages entity metadata\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.core_EntityRegistry_CTor()
			_core.IncRef(self.handle)
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.EntityRegistry{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.EntityRegistry ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def RegisterEntity(self, entityType, tableName, metadata, goRun=False):
		"""RegisterEntity(object entityType, str tableName, object metadata) 
		
		RegisterEntity registers an entity with its metadata
		"""
		_core.core_EntityRegistry_RegisterEntity(self.handle, entityType.handle, tableName, metadata.handle, goRun)
	def RegisterEntityByName(self, entityName, metadata, goRun=False):
		"""RegisterEntityByName(str entityName, object metadata) 
		
		RegisterEntityByName registers an entity by name (for high-level API)
		"""
		_core.core_EntityRegistry_RegisterEntityByName(self.handle, entityName, metadata.handle, goRun)
	def GetEntityGopy(self, typeName):
		"""GetEntityGopy(str typeName) object, str
		
		GetEntityGopy returns entity metadata by type name (gopy-compatible version)
		"""
		return EntityMetadata(handle=_core.core_EntityRegistry_GetEntityGopy(self.handle, typeName))

# Python type for struct core.TakeoAPI
class TakeoAPI(go.GoClass):
	"""TakeoAPI - Interface simplifiée pour les bindings gopy\nÉvite les types complexes qui posent des problèmes avec gopy\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.core_TakeoAPI_CTor()
			_core.IncRef(self.handle)
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.TakeoAPI{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.TakeoAPI ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def RegisterEntity(self, name, tableName, columnsJSON, primaryKey):
		"""RegisterEntity(str name, str tableName, str columnsJSON, str primaryKey) str
		
		RegisterEntity enregistre une entité (version simplifiée pour gopy)
		"""
		return _core.core_TakeoAPI_RegisterEntity(self.handle, name, tableName, columnsJSON, primaryKey)
	def Save(self, entityType, dataJSON):
		"""Save(str entityType, str dataJSON) long, str
		
		Save sauvegarde une entité (version simplifiée)
		"""
		return _core.core_TakeoAPI_Save(self.handle, entityType, dataJSON)
	def FindByID(self, entityType, id):
		"""FindByID(str entityType, long id) str, str
		
		FindByID trouve une entité par ID (retourne JSON string pour simplicité)
		"""
		return _core.core_TakeoAPI_FindByID(self.handle, entityType, id)
	def FindAll(self, entityType):
		"""FindAll(str entityType) str, str
		
		FindAll trouve toutes les entités (retourne JSON string)
		"""
		return _core.core_TakeoAPI_FindAll(self.handle, entityType)
	def Update(self, entityType, id, updateJSON):
		"""Update(str entityType, long id, str updateJSON) str
		
		Update met à jour une entité
		"""
		return _core.core_TakeoAPI_Update(self.handle, entityType, id, updateJSON)
	def Delete(self, entityType, id):
		"""Delete(str entityType, long id) str
		
		Delete supprime une entité
		"""
		return _core.core_TakeoAPI_Delete(self.handle, entityType, id)
	def CreateTable(self, entityType):
		"""CreateTable(str entityType) str
		
		CreateTable crée la table pour une entité
		"""
		return _core.core_TakeoAPI_CreateTable(self.handle, entityType)
	def DropTable(self, entityType):
		"""DropTable(str entityType) str
		
		DropTable supprime la table d'une entité
		"""
		return _core.core_TakeoAPI_DropTable(self.handle, entityType)
	def Close(self):
		"""Close() str
		
		Close ferme la connexion
		"""
		return _core.core_TakeoAPI_Close(self.handle)
	def Ping(self):
		"""Ping() str
		
		Ping vérifie la connectivité
		"""
		return _core.core_TakeoAPI_Ping(self.handle)

# Python type for struct core.ColumnMetadata
class ColumnMetadata(go.GoClass):
	"""ColumnMetadata holds metadata about a column\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.core_ColumnMetadata_CTor()
			_core.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Type = args[1]
			if "Type" in kwargs:
				self.Type = kwargs["Type"]
			if  2 < len(args):
				self.IsPrimaryKey = args[2]
			if "IsPrimaryKey" in kwargs:
				self.IsPrimaryKey = kwargs["IsPrimaryKey"]
			if  3 < len(args):
				self.IsAutoIncrement = args[3]
			if "IsAutoIncrement" in kwargs:
				self.IsAutoIncrement = kwargs["IsAutoIncrement"]
			if  4 < len(args):
				self.IsNullable = args[4]
			if "IsNullable" in kwargs:
				self.IsNullable = kwargs["IsNullable"]
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.ColumnMetadata{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.ColumnMetadata ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _core.core_ColumnMetadata_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_core.core_ColumnMetadata_Name_Set(self.handle, value.handle)
		else:
			_core.core_ColumnMetadata_Name_Set(self.handle, value)
	@property
	def Type(self):
		return _core.core_ColumnMetadata_Type_Get(self.handle)
	@Type.setter
	def Type(self, value):
		if isinstance(value, go.GoClass):
			_core.core_ColumnMetadata_Type_Set(self.handle, value.handle)
		else:
			_core.core_ColumnMetadata_Type_Set(self.handle, value)
	@property
	def IsPrimaryKey(self):
		return _core.core_ColumnMetadata_IsPrimaryKey_Get(self.handle)
	@IsPrimaryKey.setter
	def IsPrimaryKey(self, value):
		if isinstance(value, go.GoClass):
			_core.core_ColumnMetadata_IsPrimaryKey_Set(self.handle, value.handle)
		else:
			_core.core_ColumnMetadata_IsPrimaryKey_Set(self.handle, value)
	@property
	def IsAutoIncrement(self):
		return _core.core_ColumnMetadata_IsAutoIncrement_Get(self.handle)
	@IsAutoIncrement.setter
	def IsAutoIncrement(self, value):
		if isinstance(value, go.GoClass):
			_core.core_ColumnMetadata_IsAutoIncrement_Set(self.handle, value.handle)
		else:
			_core.core_ColumnMetadata_IsAutoIncrement_Set(self.handle, value)
	@property
	def IsNullable(self):
		return _core.core_ColumnMetadata_IsNullable_Get(self.handle)
	@IsNullable.setter
	def IsNullable(self, value):
		if isinstance(value, go.GoClass):
			_core.core_ColumnMetadata_IsNullable_Set(self.handle, value.handle)
		else:
			_core.core_ColumnMetadata_IsNullable_Set(self.handle, value)

# Python type for struct core.DB
class DB(go.GoClass):
	"""DB represents the database connection and operations\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.core_DB_CTor()
			_core.IncRef(self.handle)
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.DB{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.DB ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Close(self):
		"""Close() str
		
		Close closes the database connection
		"""
		return _core.core_DB_Close(self.handle)
	def Ping(self):
		"""Ping() str
		
		Ping checks if the database connection is alive
		"""
		return _core.core_DB_Ping(self.handle)

# Python type for struct core.TakeoManager
class TakeoManager(go.GoClass):
	"""TakeoManager - Interface principale haut niveau pour l'utilisateur\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.core_TakeoManager_CTor()
			_core.IncRef(self.handle)
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.TakeoManager{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.TakeoManager ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def RegisterEntity(self, name, tableName, columns, primaryKey):
		"""RegisterEntity(str name, str tableName, object columns, str primaryKey) str
		
		RegisterEntity enregistre une nouvelle entité avec ses métadonnées
		"""
		return _core.core_TakeoManager_RegisterEntity(self.handle, name, tableName, columns.handle, primaryKey)
	def Save(self, entityType, entityData):
		"""Save(str entityType, object entityData) long, str
		
		Save sauvegarde une entité et retourne son ID
		"""
		return _core.core_TakeoManager_Save(self.handle, entityType, entityData.handle)
	def SaveBatch(self, entityType, entitiesData):
		"""SaveBatch(str entityType, []object entitiesData) []long, str
		
		SaveBatch sauvegarde plusieurs entités en une transaction et retourne leurs IDs
		"""
		return go.Slice_int64(handle=_core.core_TakeoManager_SaveBatch(self.handle, entityType, entitiesData.handle))
	def FindByID(self, entityType, id):
		"""FindByID(str entityType, long id) object, str
		
		FindByID trouve une entité par son ID
		"""
		return Map_string_interface_(handle=_core.core_TakeoManager_FindByID(self.handle, entityType, id))
	def FindAll(self, entityType):
		"""FindAll(str entityType) []object, str
		
		FindAll trouve toutes les entités d'un type
		"""
		return Slice_Map_string_interface_(handle=_core.core_TakeoManager_FindAll(self.handle, entityType))
	def FindWhere(self, entityType, conditions):
		"""FindWhere(str entityType, object conditions) []object, str
		
		FindWhere trouve des entités selon des conditions
		"""
		return Slice_Map_string_interface_(handle=_core.core_TakeoManager_FindWhere(self.handle, entityType, conditions.handle))
	def Update(self, entityType, id, updates):
		"""Update(str entityType, long id, object updates) str
		
		Update met à jour une entité
		"""
		return _core.core_TakeoManager_Update(self.handle, entityType, id, updates.handle)
	def UpdateBatch(self, entityType, updates):
		"""UpdateBatch(str entityType, []object updates) str
		
		UpdateBatch met à jour plusieurs entités en batch
		"""
		return _core.core_TakeoManager_UpdateBatch(self.handle, entityType, updates.handle)
	def Delete(self, entityType, id):
		"""Delete(str entityType, long id) str
		
		Delete supprime une entité par ID
		"""
		return _core.core_TakeoManager_Delete(self.handle, entityType, id)
	def DeleteBatch(self, entityType, ids):
		"""DeleteBatch(str entityType, []long ids) str
		
		DeleteBatch supprime plusieurs entités par ID en batch
		"""
		return _core.core_TakeoManager_DeleteBatch(self.handle, entityType, ids.handle)
	def DeleteWhere(self, entityType, conditions):
		"""DeleteWhere(str entityType, object conditions) long, str
		
		DeleteWhere supprime des entités selon des conditions
		"""
		return _core.core_TakeoManager_DeleteWhere(self.handle, entityType, conditions.handle)
	def CreateTable(self, entityType):
		"""CreateTable(str entityType) str
		
		CreateTable crée la table pour une entité
		"""
		return _core.core_TakeoManager_CreateTable(self.handle, entityType)
	def DropTable(self, entityType):
		"""DropTable(str entityType) str
		
		DropTable supprime la table d'une entité
		"""
		return _core.core_TakeoManager_DropTable(self.handle, entityType)
	def BeginTransaction(self):
		"""BeginTransaction() object, str
		
		BeginTransaction commence une nouvelle transaction
		"""
		return TakeoTransaction(handle=_core.core_TakeoManager_BeginTransaction(self.handle))
	def Close(self):
		"""Close() str
		
		Close ferme la connexion
		"""
		return _core.core_TakeoManager_Close(self.handle)
	def Ping(self):
		"""Ping() str
		
		Ping vérifie la connectivité
		"""
		return _core.core_TakeoManager_Ping(self.handle)

# Python type for struct core.TakeoORM
class TakeoORM(go.GoClass):
	"""TakeoORM is the main interface exported to Python\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.core_TakeoORM_CTor()
			_core.IncRef(self.handle)
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.TakeoORM{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.TakeoORM ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Close(self):
		"""Close() str
		
		Close closes the database connection
		"""
		return _core.core_TakeoORM_Close(self.handle)
	def Ping(self):
		"""Ping() str
		
		Ping checks database connectivity
		"""
		return _core.core_TakeoORM_Ping(self.handle)
	def RegisterEntityByName(self, typeName, tableName, columns, primaryKey, autoIncrementColumns, goRun=False):
		"""RegisterEntityByName(str typeName, str tableName, object columns, str primaryKey, []str autoIncrementColumns) 
		
		RegisterEntityByName registers an entity by providing metadata directly
		This is designed to be called from Python where reflection is limited
		"""
		_core.core_TakeoORM_RegisterEntityByName(self.handle, typeName, tableName, columns.handle, primaryKey, autoIncrementColumns.handle, goRun)
	def CreateEntity(self, typeName, values):
		"""CreateEntity(str typeName, object values) str
		
		CreateEntity creates a new entity record
		"""
		return _core.core_TakeoORM_CreateEntity(self.handle, typeName, values.handle)
	def CreateEntitiesBatch(self, typeName, entitiesData):
		"""CreateEntitiesBatch(str typeName, []object entitiesData) str
		
		CreateEntitiesBatch creates multiple entities in a single transaction (batch operation)
		"""
		return _core.core_TakeoORM_CreateEntitiesBatch(self.handle, typeName, entitiesData.handle)
	def FindEntityByID(self, typeName, id):
		"""FindEntityByID(str typeName, str id) object, str
		
		FindEntityByID finds an entity by its primary key
		"""
		return Map_string_interface_(handle=_core.core_TakeoORM_FindEntityByID(self.handle, typeName, id))
	def FindAllEntities(self, typeName):
		"""FindAllEntities(str typeName) []object, str
		
		FindAllEntities finds all entities of a given type
		"""
		return Slice_Map_string_interface_(handle=_core.core_TakeoORM_FindAllEntities(self.handle, typeName))
	def UpdateEntity(self, typeName, id, values):
		"""UpdateEntity(str typeName, str id, object values) str
		
		UpdateEntity updates an existing entity
		"""
		return _core.core_TakeoORM_UpdateEntity(self.handle, typeName, id, values.handle)
	def DeleteEntity(self, typeName, id):
		"""DeleteEntity(str typeName, str id) str
		
		DeleteEntity deletes an entity by its primary key
		"""
		return _core.core_TakeoORM_DeleteEntity(self.handle, typeName, id)
	def DeleteEntitiesBatch(self, typeName, ids):
		"""DeleteEntitiesBatch(str typeName, []str ids) str
		
		DeleteEntitiesBatch deletes multiple entities by their primary keys in a single transaction
		"""
		return _core.core_TakeoORM_DeleteEntitiesBatch(self.handle, typeName, ids.handle)

# Python type for struct core.TakeoTransaction
class TakeoTransaction(go.GoClass):
	"""TakeoTransaction - Gestion des transactions\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.core_TakeoTransaction_CTor()
			_core.IncRef(self.handle)
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.TakeoTransaction{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.TakeoTransaction ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Save(self, entityType, entityData):
		"""Save(str entityType, object entityData) long, str
		
		Save dans une transaction
		"""
		return _core.core_TakeoTransaction_Save(self.handle, entityType, entityData.handle)
	def Commit(self):
		"""Commit() str
		
		Commit finalise la transaction
		"""
		return _core.core_TakeoTransaction_Commit(self.handle)
	def Rollback(self):
		"""Rollback() str
		
		Rollback annule la transaction
		"""
		return _core.core_TakeoTransaction_Rollback(self.handle)

# Python type for struct core.UpdateData
class UpdateData(go.GoClass):
	"""UpdateData structure pour les updates en batch\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.core_UpdateData_CTor()
			_core.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Updates = args[1]
			if "Updates" in kwargs:
				self.Updates = kwargs["Updates"]
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.UpdateData{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.UpdateData ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ID(self):
		return _core.core_UpdateData_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_core.core_UpdateData_ID_Set(self.handle, value.handle)
		else:
			_core.core_UpdateData_ID_Set(self.handle, value)
	@property
	def Updates(self):
		return Map_string_interface_(handle=_core.core_UpdateData_Updates_Get(self.handle))
	@Updates.setter
	def Updates(self, value):
		if isinstance(value, go.GoClass):
			_core.core_UpdateData_Updates_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct core.EntityMetadata
class EntityMetadata(go.GoClass):
	"""EntityMetadata holds metadata about an entity\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.core_EntityMetadata_CTor()
			_core.IncRef(self.handle)
			if  0 < len(args):
				self.TableName = args[0]
			if "TableName" in kwargs:
				self.TableName = kwargs["TableName"]
			if  1 < len(args):
				self.PrimaryKey = args[1]
			if "PrimaryKey" in kwargs:
				self.PrimaryKey = kwargs["PrimaryKey"]
			if  2 < len(args):
				self.Columns = args[2]
			if "Columns" in kwargs:
				self.Columns = kwargs["Columns"]
			if  3 < len(args):
				self.ColumnOrder = args[3]
			if "ColumnOrder" in kwargs:
				self.ColumnOrder = kwargs["ColumnOrder"]
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.EntityMetadata{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.EntityMetadata ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def TableName(self):
		return _core.core_EntityMetadata_TableName_Get(self.handle)
	@TableName.setter
	def TableName(self, value):
		if isinstance(value, go.GoClass):
			_core.core_EntityMetadata_TableName_Set(self.handle, value.handle)
		else:
			_core.core_EntityMetadata_TableName_Set(self.handle, value)
	@property
	def PrimaryKey(self):
		return _core.core_EntityMetadata_PrimaryKey_Get(self.handle)
	@PrimaryKey.setter
	def PrimaryKey(self, value):
		if isinstance(value, go.GoClass):
			_core.core_EntityMetadata_PrimaryKey_Set(self.handle, value.handle)
		else:
			_core.core_EntityMetadata_PrimaryKey_Set(self.handle, value)
	@property
	def Columns(self):
		return Map_string_core_ColumnMetadata(handle=_core.core_EntityMetadata_Columns_Get(self.handle))
	@Columns.setter
	def Columns(self, value):
		if isinstance(value, go.GoClass):
			_core.core_EntityMetadata_Columns_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ColumnOrder(self):
		return go.Slice_string(handle=_core.core_EntityMetadata_ColumnOrder_Get(self.handle))
	@ColumnOrder.setter
	def ColumnOrder(self, value):
		if isinstance(value, go.GoClass):
			_core.core_EntityMetadata_ColumnOrder_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def BuildSelectQuery(self):
		"""BuildSelectQuery() str
		
		BuildSelectQuery builds a SELECT query for an entity
		"""
		return _core.core_EntityMetadata_BuildSelectQuery(self.handle)
	def BuildInsertQuery(self):
		"""BuildInsertQuery() str
		
		BuildInsertQuery builds an INSERT query for an entity
		"""
		return _core.core_EntityMetadata_BuildInsertQuery(self.handle)
	def BuildUpdateQuery(self):
		"""BuildUpdateQuery() str
		
		BuildUpdateQuery builds an UPDATE query for an entity
		"""
		return _core.core_EntityMetadata_BuildUpdateQuery(self.handle)
	def BuildDeleteQuery(self):
		"""BuildDeleteQuery() str
		
		BuildDeleteQuery builds a DELETE query for an entity
		"""
		return _core.core_EntityMetadata_BuildDeleteQuery(self.handle)

# Python type for struct core.Repository
class Repository(go.GoClass):
	"""Repository provides CRUD operations for entities\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_core.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_core.IncRef(self.handle)
		else:
			self.handle = _core.core_Repository_CTor()
			_core.IncRef(self.handle)
	def __del__(self):
		_core.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.Repository{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'core.Repository ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Create(self, entity):
		"""Create(str entity) str
		
		Create inserts a new entity into the database
		"""
		return _core.core_Repository_Create(self.handle, entity)
	def FindByID(self, entityType, id, result):
		"""FindByID(object entityType, str id, str result) str
		
		FindByID finds an entity by its primary key
		"""
		return _core.core_Repository_FindByID(self.handle, entityType.handle, id, result)
	def FindAll(self, entityType, results):
		"""FindAll(object entityType, str results) str
		
		FindAll retrieves all entities of a given type
		"""
		return _core.core_Repository_FindAll(self.handle, entityType.handle, results)
	def Update(self, entity):
		"""Update(str entity) str
		
		Update updates an existing entity in the database
		"""
		return _core.core_Repository_Update(self.handle, entity)
	def Delete(self, entityType, id):
		"""Delete(object entityType, str id) str
		
		Delete deletes an entity by its primary key
		"""
		return _core.core_Repository_Delete(self.handle, entityType.handle, id)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewEntityRegistry():
	"""NewEntityRegistry() object
	
	NewEntityRegistry creates a new entity registry
	"""
	return EntityRegistry(handle=_core.core_NewEntityRegistry())
def NewTakeoAPI(host, port, user, password, database, sslmode):
	"""NewTakeoAPI(str host, int port, str user, str password, str database, str sslmode) object, str
	
	NewTakeoAPI crée une nouvelle instance de l'API simplifiée
	"""
	return TakeoAPI(handle=_core.core_NewTakeoAPI(host, port, user, password, database, sslmode))
def NewDB(config):
	"""NewDB(object config) object, str
	
	NewDB creates a new database connection
	"""
	return DB(handle=_core.core_NewDB(config.handle))
def NewTakeoManager(host, port, user, password, database, sslmode):
	"""NewTakeoManager(str host, int port, str user, str password, str database, str sslmode) object, str
	
	NewTakeoManager creates a new high-level ORM manager
	"""
	return TakeoManager(handle=_core.core_NewTakeoManager(host, port, user, password, database, sslmode))
def NewTakeoORM(host, port, user, password, database, sslmode):
	"""NewTakeoORM(str host, int port, str user, str password, str database, str sslmode) object, str
	
	NewTakeoORM creates a new TakeoORM instance
	"""
	return TakeoORM(handle=_core.core_NewTakeoORM(host, port, user, password, database, sslmode))
def ExtractEntityMetadata(entityType, tableName):
	"""ExtractEntityMetadata(object entityType, str tableName) object
	
	ExtractEntityMetadata extracts metadata from a struct using reflection
	"""
	return EntityMetadata(handle=_core.core_ExtractEntityMetadata(entityType.handle, tableName))
def NewRepository(db, registry):
	"""NewRepository(object db, object registry) object
	
	NewRepository creates a new repository
	"""
	return Repository(handle=_core.core_NewRepository(db.handle, registry.handle))


# ---- Functions ---


